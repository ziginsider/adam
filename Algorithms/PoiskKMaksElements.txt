#Самый быстрый алгоритм поиска k максимальных элементов в случайном порядке.

1 подзадача:

Дан массив (для простоты все значения массива уникальны), случайным образом выбрать один из его элементов и вычислить какой индекс был бы у этого элемента, если бы массив был отсортирован. Решить задачу не сортируя массив.



2 подзадача:

Дан массив, дан элемент массива v и позиция элемента в отсортированном массиве. Написать функцию, которая возвращает новый массив, в котором v стоит на отсортированной позиции, все позиции до v заняты элементами большими v, все позиции после v заняты элементами меньшими v.



Алгоритм поиска k максимальных элементов массива:

Случайным образом v и отфильтровать массив относительно v (подзадачи 1 и 2)



Рассмотреть 3 возможных случая



Индекс v равен k – задача решена. Первые k полученного массива максимальные.



Индекс v больше k – свели задачу к меньшей. Следующей итерацией ищем k максимальных элементов среди элементов массива, чьи индексы меньше индекса v.



Индекс v меньше k - свели задачу к меньшей. Следующей итерацией ищем k – indexOf(v) максимальных элементов среди элементов массива, чьи индексы больше индекса v.



Сложность алгоритма

n - это сложность преобразования массива в такой, в котором v стоит на отсортированной позиции, все позиции до v заняты элементами большими v, все позиции после v заняты элементами меньшими v. (Мы там пробегаем по всем элементам массива, это занимает n единиц времени)



Операция сортировки массива относительно v условно делит массив на 2 части - правую и левую.



Дальше произойдет рекурсия на правой или левой части массива. Мы не знаем, на какой из частей произойдет рекурсия и какая из частей больше. Вероятность быть больше у обеих частей массива одинакова. То есть с вероятностью 1/2 размер правой части не меньше n/2 и с вероятностью 1/2 размер левой части не меньше n/2. Если рекурсия сработает на меньшей части, то время выполнения алгоритма на ней не превосходит время работы алгоритма на n/2 элементах = T(n/2). Если рекурсия сработает на большей части, то время работы алгоритма может доходить практически до время работы алгоритма на n элементах = T(n).



Таким образом вмести с вероятностями мы получаем следующую оценку сверху



T(n) <= n + 1/2T(n/2) + 1/2T(n)



Докажем теперь по индукции, что T(n)<=4n (см. пояснение ниже)



T(1) = 1 <= 4 Если в массиве всего 1 элемент, то всемя работы алгоритма = 1.



T(n) <= n + 1/2T(n/2) + 1/2T(n) <= n + 1/2 * 2n + 1/2 * 4n = n + n + 2n = 4n



Мы показали, что для любого n T(n) <= 4n



4n это O(n), т.е. время работы алгоритма линейное.



Существует несколько способов получить оценку сложности 4n. Один из них - графически. Можно построить график зависимости времени работы алгоритма от n. По графику будет видно, что сложность линейная. То есть, поскольку T(n)<=n +1/2T(n/2)+1/2T(n) то T(n)<=n+Сn/4+Сn/2. Теперь осталось найти такую константу С, чтобы было верно неравенство T(n)<=n+Сn/4+Сn/2<=C*n



(1 + C/4 + C/2)<=Cn



C>=4



После этого остается только доказать по индукции, что неравенство T(n)<=4n верно.